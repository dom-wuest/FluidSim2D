#version 450

layout (binding = 0, rgba8 ) uniform writeonly image2D resultImage;

layout (binding = 1) readonly buffer SolidsIn {
    int solids[ ];
};

layout (binding = 2) readonly buffer UIn {
    float u[ ];
};

layout (binding = 3) readonly buffer VIn {
    float v[ ];
};

layout (binding = 4) readonly buffer PIn {
    float pressure[];
};

layout (binding = 5) readonly buffer DyeIn {
    vec4 dye[];
};

layout (push_constant) uniform PushConstants
{
    uint width;
    uint height;
    uint sim_width;
    uint sim_height;
    float deltaTime;
} p;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#define S_COORD(i,j) (i) + (j) * p.sim_width
#define U_COORD(i,j) (i) + (j) * (p.sim_width + 1)
#define V_COORD(i,j) (i) + (j) * p.sim_width
//#define SHOW_PRESSURE

float nearest_p(float x, float y){
    // x,y in [0.0,1.0)
    float x_l = floor(x * float(p.sim_width));
    float y_l = floor(y * float(p.sim_height));
    return float(pressure[int(x_l) + p.sim_width * int(y_l)]);
}
float nearest_s(float x, float y){
    // x,y in [0.0,1.0)
    float x_l = floor(x * float(p.sim_width));
    float y_l = floor(y * float(p.sim_height));
    return float(solids[int(x_l) + p.sim_width * int(y_l)]);
}
vec4 nearest_dye(float x, float y){
    // x,y in [0.0,1.0)
    float x_l = floor(x * float(p.sim_width));
    float y_l = floor(y * float(p.sim_height));
    return dye[int(x_l) + p.sim_width * int(y_l)];
}
float nearest_u(float x, float y){
    // x,y in [0.0,1.0)
    float x_l = floor(x * float(p.sim_width+1));
    float y_l = floor(y * float(p.sim_height+1));
    return float(u[int(x_l) + (p.sim_width + 1) * int(y_l)]);
}
float nearest_v(float x, float y){
    // x,y in [0.0,1.0)
    float x_l = floor(x * float(p.sim_width + 1));
    float y_l = floor(y * float(p.sim_height + 1));
    return float(v[int(x_l) + (p.sim_width + 1) * int(y_l)]);
}

float bilerp_u(float x, float y){
    // x,y in [0.0,1.0)
    float s = floor(x * (float(p.sim_width)+1.0));
    float t = floor(y * (float(p.sim_height)) - 0.5);
    float dx = x * (float(p.sim_width)+1.0) - s;
    float dy = y * (float(p.sim_height)) - t - 0.5;

    //s = s + 1.0;
    //t = t + 1.0;

    int s0 = max(int(s), 0);
    int s1 = min(int(s) + 1, int(p.sim_width));
    int t0 = max(int(t), 0);
    int t1 = min(int(t) + 1, int(p.sim_height) - 1);

    float A = float(u[s0 + (p.sim_width+1) * t0]);
    float B = float(u[s1 + (p.sim_width+1) * t0]);
    float C = float(u[s0 + (p.sim_width+1) * t1]);
    float D = float(u[s1 + (p.sim_width+1) * t1]);
    return (A * (1.0-dx) + B * dx) * (1.0-dy) + (C * (1.0-dx) + D * dx) * dy;
}

float bilerp_v(float x, float y){
    // x,y in [0.0,1.0)
    float s = floor(x * (float(p.sim_width)) - 0.5);
    float t = floor(y * (float(p.sim_height)+1.0));
    float dx = x * (float(p.sim_width)) - s -0.5;
    float dy = y * (float(p.sim_height)+1.0) - t;

    //s = s + 1.0;
    //t = t + 1.0;

    int s0 = max(int(s), 0);
    int s1 = min(int(s) + 1, int(p.sim_width) - 1);
    int t0 = max(int(t), 0);
    int t1 = min(int(t) + 1, int(p.sim_height));

    float A = float(v[s0 + (p.sim_width) * t0]);
    float B = float(v[s1 + (p.sim_width) * t0]);
    float C = float(v[s0 + (p.sim_width) * t1]);
    float D = float(v[s1 + (p.sim_width) * t1]);
    return (A * (1.0-dx) + B * dx) * (1.0-dy) + (C * (1.0-dx) + D * dx) * dy;
}

vec4 sciColor(float val) {
    // val in [0,1)
    vec3 colorMap[] = vec3[](vec3(0.050,0.029,0.527), vec3(0.327,0.006,0.646), vec3(0.545,0.038,0.647), vec3(0.724,0.197,0.537), vec3(0.858,0.359,0.407), vec3(0.955,0.533,0.285), vec3(0.994,0.738,0.167), vec3(1.0,0.940,0.131));

    int idx = int(floor(val * 7.0));
    float dx = val * 7.0 - float(idx);
    vec4 A = vec4(colorMap[idx],1.0);
    vec4 B = vec4(colorMap[idx+1],1.0);
    return mix(A,B, dx);
}

vec4 bilerp_dye(float x, float y){
    // x,y in [0.0,1.0)
    float s = floor(x * float(p.sim_width)-0.5);
    float t = floor(y * float(p.sim_height)-0.5);
    float dx = x * float(p.sim_width) - s - 0.5;
    float dy = y * float(p.sim_height)- t - 0.5;

    int s0 = max(int(s), 0);
    int s1 = min(int(s) + 1, int(p.sim_width) - 1);
    int t0 = max(int(t), 0);
    int t1 = min(int(t) + 1, int(p.sim_height) - 1);

    vec4 A = dye[S_COORD(s0,t0)];
    vec4 B = dye[S_COORD(s1,t0)];
    vec4 C = dye[S_COORD(s0,t1)];
    vec4 D = dye[S_COORD(s1,t1)];
    return mix(mix(A,B,dx),mix(C,D,dx),dy);
}

void main(){

    uint gIDx = gl_GlobalInvocationID.x;
    uint gIDy = gl_GlobalInvocationID.y;

    if(gIDx >= p.width || gIDy >= p.height){
        return;
    }

    float x = float(gIDx) / float(p.width);
    float y = float(gIDy) / float(p.height);
    //float solid = nearest_solids(x,y);
    //float u_x = bilerp_u(x,y);
    //float v_x = bilerp_v(x,y);
    //vec4 color = vec4(u_x,v_x,0.0,1.0);
#ifdef SHOW_PRESSURE
    float press = nearest_p(x, y) * 10.0 + .3;
    press = min(0.999, press);
    vec4 color = sciColor(press);
#else
    float vel_u = bilerp_u(x, y);
    float vel_v = bilerp_v(x, y) * 1.5;
    vec4 color = vec4(vel_u,vel_v,-vel_v,1.0);
#endif

    if(nearest_s(x,y) < 0.5){
        // solid -> white!
        //color = vec4(1.0,1.0,1.0,1.0);
    }
    color = bilerp_dye(x,y);
    color.w = 1.0;
    imageStore( resultImage, ivec2(gl_GlobalInvocationID.xy), color);
}